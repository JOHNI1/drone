<?xml version="1.0" ?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro">


    <xacro:macro name="extra_channel" params="channel _type _multiplier _jointName _offset _p_gain _i_gain _d_gain 
                                                          _i_max _i_min _cmd_max _cmd_min">
        <control channel="${channel}">
            <type>${_type}</type>
            <multiplier>${_multiplier}</multiplier>
            <jointName>${_jointName}</jointName>
            <offset>${_offset}</offset>
            <p_gain>${_p_gain}</p_gain>
            <i_gain>${_i_gain}</i_gain>
            <d_gain>${_d_gain}</d_gain>
            <i_max>${_i_max}</i_max>
            <i_min>${_i_min}</i_min>
            <cmd_max>${_cmd_max}</cmd_max>
            <cmd_min>${_cmd_min}</cmd_min>
            <controlVelocitySlowdownSim>1</controlVelocitySlowdownSim>
        </control>
    </xacro:macro>

    
    <xacro:macro name="ardupilot_plugin" params="number_of_arms multiplier cws offset p_gain i_gain d_gain i_max i_min cmd_max cmd_min **extra_ardupilot_plugin_settings">

        <xacro:property name="cw_list" value="${cws.split(' ')}" />
        <gazebo>
            <plugin name="arducopter_plugin" filename="libArduPilotPlugin.so">
                <fdm_addr>127.0.0.1</fdm_addr>
                <fdm_port_in>9002</fdm_port_in>
                <fdm_port_out>9003</fdm_port_out>
                <!-- <modelXYZToAirplaneXForwardZDown>0 0 0 3.141593 0 0</modelXYZToAirplaneXForwardZDown>
                <gazeboXYZToNED>0 0 0 3.141593 0 0</gazeboXYZToNED> -->
                <modelXYZToAirplaneXForwardZDown>0 0 0 ${pi} 0 0</modelXYZToAirplaneXForwardZDown>
                <gazeboXYZToNED>0 0 0 ${pi} 0 0</gazeboXYZToNED>
                <imuName>imu_link::imu_sensor</imuName>
                <connectionTimeoutMaxCount>5</connectionTimeoutMaxCount>

                <xacro:macro name="create_arms" params="i">
                    <xacro:if value="${i > 0}">
                        <!-- Here define the arm -->
                        <xacro:property name="counter" value="${number_of_arms - i}" />
                        <xacro:property name="jointName" value="rotor_joint_${str(counter)}" />
                        <xacro:property name="directed_multiplier" value="${multiplier * ((int(cw_list[counter]) * (-2)) + 1)}" />
                        <control channel="${counter}">
                            <type>VELOCITY</type>
                            <multiplier>${directed_multiplier}</multiplier>
                            <jointName>${jointName}</jointName>
                            <offset>${offset}</offset>
                            <p_gain>${p_gain}</p_gain>
                            <i_gain>${i_gain}</i_gain>
                            <d_gain>${d_gain}</d_gain>
                            <i_max>${i_max}</i_max>
                            <i_min>${i_min}</i_min>
                            <cmd_max>${cmd_max}</cmd_max>
                            <cmd_min>${cmd_min}</cmd_min>
                            <controlVelocitySlowdownSim>1</controlVelocitySlowdownSim>
                        </control>
                        <!-- Recursively call the macro with a decremented count -->
                        <xacro:create_arms i="${i - 1}"/>
                    </xacro:if>
                </xacro:macro>
                <!-- Initial call to the macro with the desired number of joints -->
                <xacro:create_arms i="${int(number_of_arms)}"/>
                <!-- end Define arms! -->
                


                <xacro:insert_block name="extra_ardupilot_plugin_settings"/>
            </plugin>
        </gazebo>
    </xacro:macro>
</robot>


  <!-- /// \brief Interface ArduPilot from ardupilot stack
  /// modeled after SITL/SIM_*
  ///
  /// The plugin requires the following parameters:
  /// <control>             control description block
  ///    <!- inputs from Ardupilot ->
  ///    channel            attribute, ardupilot control channel
  ///    multiplier         command multiplier
  ///    <!- output to Gazebo ->
  ///    type               type of control, VELOCITY, POSITION or EFFORT
  ///    <p_gain>           velocity pid p gain
  ///    <i_gain>           velocity pid i gain
  ///    <d_gain>           velocity pid d gain
  ///    <i_max>            velocity pid max integral correction
  ///    <i_min>            velocity pid min integral correction
  ///    <cmd_max>          velocity pid max command torque
  ///    <cmd_min>          velocity pid min command torque
  ///    <jointName>        motor joint, torque applied here
  ///    <turningDirection> rotor turning direction, 'cw' or 'ccw'
  ///    frequencyCutoff    filter incoming joint state
  ///    samplingRate       sampling rate for filtering incoming joint state
  ///    <rotorVelocitySlowdownSim> for rotor aliasing problem, experimental
  /// <imuName>     scoped name for the imu sensor
  /// <connectionTimeoutMaxCount> timeout before giving up on
  ///                             controller synchronization -->
